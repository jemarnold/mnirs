% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/resample_mnirs.R
\name{resample_mnirs}
\alias{resample_mnirs}
\title{Re-sample a data frame}
\usage{
resample_mnirs(
  data,
  time_channel = NULL,
  sample_rate = NULL,
  resample_rate = sample_rate,
  resample_time = NULL,
  method = c("linear", "locf", "NA"),
  verbose = TRUE
)
}
\arguments{
\item{data}{A data frame of class \emph{"mnirs"} containing at least one
column with numeric time or sample values, and one column with numeric
mNIRS values, along with metadata.}

\item{time_channel}{A character string indicating the time or sample channel
name. Must match column names in \code{data} exactly. Will be taken from
metadata if not defined explicitly.}

\item{sample_rate}{A numeric value for the sample rate in Hz. Will be taken
from metadata or estimated from \code{time_channel} if not defined explicitly.}

\item{resample_rate}{An \emph{optional} numeric value indicating the desired
output sample rate (in Hz) to re-sample the data frame. The \emph{default}
\code{resample_rate = sample_rate} will interpolate over missing and repeated
samples within the bounds of the existing data rounded to the nearest
value in Hz.}

\item{resample_time}{An \emph{optional} numeric value indicating the desired
sample time (in seconds) to re-sample the data frame.}

\item{method}{A character string indicating how to handle resampling
(see \emph{Details} for more on each method):
\describe{
\item{\code{"linear"}}{Re-samples and replaces \code{NA}s via linear
interpolation (the \emph{default}) using \code{\link[stats:approxfun]{stats::approx()}}.}
\item{\code{"locf"}}{(\emph{"Last observation carried forward"}). Re-samples and
replaces \code{NA}s with the most recent valid non-\code{NA} value to the left
for trailing samples or to the right for leading samples, using
\code{\link[stats:approxfun]{stats::approx()}}.}
\item{\code{"NA"}}{Re-samples by matching values to their nearest value of
\code{time_channel}, \emph{without} interpolating across new samples or \code{NA}s in
the original data frame.}
}}

\item{verbose}{A logical to return (the \emph{default}) or silence warnings and
messages which can be used for data error checking. Abort errors will
always be returned.}
}
\value{
A \link[tibble:tibble-package]{tibble} of class \emph{"mnirs"} with metadata
available with \code{attributes()}.
}
\description{
Up- or down-sample the number of samples in an \emph{"mnirs"} data frame
using interpolation.
}
\details{
This function uses \code{\link[=replace_missing]{replace_missing()}} (based on \code{\link[stats:approxfun]{stats::approx()}}) to
interpolate across new samples in the re-sampled data range.

\code{time_channel} and \code{sample_rate} can be retrieved automatically from
\code{data} of class \emph{"mnirs"} which has been processed with \code{{mnirs}},
if not defined explicitly.

Otherwise, \code{sample_rate} will be estimated from the values in \code{time_channel}.
However, this may return unexpected values, and it is safer to define
\code{sample_rate} explicitly.

The \emph{default} setting \code{resample_rate = sample_rate} will interpolate over
missing and repeated samples within the bounds of the existing data
rounded to the nearest \code{sample_rate}.

By \emph{default}, \code{method = "linear"} or \code{"locf"} will interpolate across \code{NA}s
in the original data and any new samples between existing values of
\code{time_channel} (see \code{?replace_missing}). Whereas \code{method = "NA"} will
match values of numeric columns from the original samples of \code{time_channel}
to the new re-sampled samples, without interpolation. Meaning \code{NA}s in the
original data and any new samples will be returned as \code{NA}.
}
\examples{
## read example data
data <- read_mnirs(
    file_path = example_mnirs("moxy_ramp"),
    nirs_channels = c(smo2 = "SmO2 Live"),
    time_channel = c(time = "hh:mm:ss"),
    verbose = FALSE
)

data

data_resampled <- resample_mnirs(
    data,
    # time_channel = NULL,         ## taken from metadata
    # sample_rate = NULL,
    # resample_rate = sample_rate, ## the default will re-sample to sample_rate
    method = "linear",             ## default linear interpolation across any new samples
    verbose = FALSE                ## will confirm the output sample rate
)

## note the altered "time" values ðŸ‘‡
data_resampled

}
