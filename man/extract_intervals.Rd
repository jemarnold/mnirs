% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/extract_intervals.R
\name{extract_intervals}
\alias{extract_intervals}
\title{Extract intervals from \emph{{mnirs}} data}
\usage{
extract_intervals(
  data,
  nirs_channels = list(NULL),
  time_channel = NULL,
  event_channel = NULL,
  sample_rate = NULL,
  event_times = NULL,
  event_labels = NULL,
  event_samples = NULL,
  span = list(c(-30, 180)),
  group_events = list("distinct", "ensemble"),
  zero_time = FALSE,
  verbose = TRUE
)
}
\arguments{
\item{data}{A data frame of class \emph{"mnirs"} containing time series data
and metadata.}

\item{nirs_channels}{A \code{list()} of character vectors indicating mNIRS
channel names to operate on within each interval (see \emph{Details}). Must
match column names in \code{data} exactly. Retrieved from metadata if not
defined explicitly.}

\item{time_channel}{A character string indicating the time or sample channel
name. Must match column names in \code{data} exactly. Retrieved from metadata
if not defined explicitly.}

\item{event_channel}{An \emph{optional} character string indicating the event or
lap channel name. Required if \code{event_labels} are specified. Must
match column names in \code{data} exactly. Retrieved from metadata if not
defined explicitly.}

\item{sample_rate}{An \emph{optional} numeric value for the exported sample rate
in Hz. If not defined explicitly, will be estimated from the data (see
\emph{Details}).}

\item{event_times}{A numeric vector of \code{time_channel} values indicating
event starts (see \emph{Details}).}

\item{event_labels}{A character vector of strings to match from
\code{event_channel}, indicating event starts.}

\item{event_samples}{An integer vector with sample indices (row numbers)
indicating event starts.}

\item{span}{A \code{list()} of two-element numeric vectors specifying the
interval around each event as \code{c(before, after)}, in units of
\code{time_channel} (see \emph{Details}).}

\item{group_events}{Either a character string or a \code{list()} of numeric
vectors specifying how to group intervals. Interval numbers are sorted
in order of appearance within \code{data}.
\describe{
\item{\code{"distinct"}}{Will extract each interval as an independent
data frame (the \emph{default}).}
\item{\code{"ensemble"}}{Will perform ensemble-averaging across all
detected intervals for each \code{nirs_channel}, and return a single
data frame.}
\item{\code{list(c(1, 2), c(3, 4))}}{Will perform ensemble-averaging across
intervals within each group and return a data frame for each group.}
}}

\item{zero_time}{A logical to re-calculate \code{time_channel} from zero or
preserve the original \code{time_channel} values (\code{FALSE}, the \emph{default}).}

\item{verbose}{A logical to display (the \emph{default}) or silence (\code{FALSE})
warnings and information messages used for troubleshooting.}
}
\value{
A named \code{list()} of \link[tibble:tibble-package]{tibbles} of class
\emph{"mnirs"} with metadata available with \code{attributes()}.
}
\description{
Detects and extracts intervals around specified events from time series
data for analysis.
}
\details{
\code{nirs_channels = list()} can be used to specify unique data channels
(column names) to operate on within intervals, according to \code{group_events}
(see below).
\itemize{
\item Channels can be specified in seperate list items (e.g.
\code{list(c("A", "B", "C"), "B", c("A", "C"))}) to include or exclude from
specific intervals. In this way, bad data channels in a single interval
can be excluded from contaminating the ensemble-averaging.
}

\verb{event_*} arguments can be used to identify intervals of interest in \code{data},
and can be specified three ways (methods can be combined):

\describe{
\item{\code{event_times}}{Numeric time values in units of \code{time_channel}.}
\item{\code{event_samples}}{Integer sample indices (row numbers).}
\item{\code{event_labels}}{Character patterns to match in \code{event_channel},
case-sensitive and must match exactly.}
}
\itemize{
\item Every unique event detected in \code{data} will be extracted according to the
\code{span} interval window around it (see below). Events can be specified in
any order. The detected intervals will be extracted and returned in the
order in which they appear.
}

\code{span = list()} will accept two-element numeric vectors indicating the
interval time window around each detected event, in units of
\code{time_channel}, e.g. seconds.
\itemize{
\item \code{span = c(before, after)} will typically have a \emph{negative} \code{before} value,
extending the interval window \emph{before} the target event, and a \emph{positive}
\code{after} value, extending the interval window \emph{after} the target event,
resulting in an interval window between
\verb{[event - span[1], event + span[2]]}. However, \code{span} will accept any
positive or negative values with reference to the target event, as long
as the range is contained within the bounds of the available \code{data}.
\item Example for three intervals:
\describe{
\item{\code{event_times = list(60, 120, 300)}}{}
\item{\code{span = list(c(-30, 30), c(30, 90), c(-60, 0))}}{
\itemize{
\item Interval 1 would range from \code{30} to \code{90} seconds.
\item Interval 2 would range from \code{150} to \code{210} seconds.
\item Interval 3 would range from \code{240} to \code{300} seconds.}
}
}
}

\code{group_events = list()} can be used to specify the grouping structure of
intervals and return either discrete or ensemble-averaged intervals.

\describe{
\item{\code{"distinct"}}{Will extract each interval as an independent
data frame.}
\item{\code{"ensemble"}}{Will perform ensemble-averaging across all
detected intervals for each \code{nirs_channel}, and return a single
data frame.}
\item{\code{list(c(1, 2), c(3, 4))}}{Will perform ensemble-averaging across
intervals within each group and return a data frame for each group.}
}
\itemize{
\item Any interval numbers omitted from \code{group_events} will be extracted as a
distinct data frame. Interval numbers beyond the number of detected
intervals will be ignored.
\item \code{group_events} will accept a named list and pass on those names to the
list of returned data frames \verb{<under development>}, e.g.
\describe{
\item{\code{group_events = list(low = c(1, 2), high = c(3, 4))}}{}
}
Otherwise, default names will be returned as \code{"interval_1"},
\code{"interval_2"}, etc. for distinct intervals; \code{"ensemble"} for
ensemble-averaging across all intervals; or \code{"group_1_2"} etc. for
custom grouping structure.
}

List items or a single vector (e.g. \code{nirs_channels = list(c("A", "B"))} or
\code{span = c(-30, 30)}) will be recycled forward for all intervals. If the
number of intervals detected exceeds the number of list items, the last
specified list item will be recycled forward to the additional intervals.
List items beyond the number of detected intervals will be ignored.

\code{zero_time = TRUE} will re-calculate numeric \code{time_channel} values
to start from zero at the target event, for each interval. Ensemble-
averaged interval times will always be zeroed. Effectively, this works best
when the event marker indicates the start of the interval. This can
return unexpected time values when the event marker itself is not
included in the interval range (e.g. with \code{span = c(30, 60)}).
}
\examples{
## read example data
data <- read_mnirs(
    example_mnirs("train.red"),
    nirs_channels = c(
        smo2_left = "SmO2 unfiltered",
        smo2_right = "SmO2 unfiltered"
    ),
    time_channel = c(time = "Timestamp (seconds passed)"),
    zero_time = TRUE,
    verbose = FALSE
) |>
    resample_mnirs(verbose = FALSE) ## avoid issues ensemble-averaging irregular samples

## extract intervals as a list of data frames
extract_intervals(
    data,
    nirs_channels = list(c(smo2_left, smo2_right)),
    event_times = c(368, 1093), ## specify interval events
    span = list(c(-20, 90)),    ## specify the event start-end timespans
    group_events = "distinct",  ## return all unique intervals
    zero_time = TRUE,           ## start time from zero
    verbose = FALSE
)

## ensemble-average across multiple intervals
interval_list <- extract_intervals(
    data,
    nirs_channels = list(c(smo2_left, smo2_right)),
    event_times = c(368, 1093),
    span = list(c(-20, 90)),
    group_events = "ensemble", ## return ensemble-averaged intervals
    zero_time = TRUE,
    verbose = FALSE
)

interval_list[[1L]]

\donttest{
  if (requireNamespace("ggplot2", quietly = TRUE)) {
    plot(interval_list[[1L]], label_time = TRUE) +
      ggplot2::geom_vline(xintercept = 0, linetype = "dotted")
  }
}

}
