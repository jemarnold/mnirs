---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>",
    fig.path = "man/figures/README-",
    out.width = "100%",
    dpi = 300
)
```

# Muscle Near-Infrared Spectroscopy (mNIRS)

<!-- badges: start -->
[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://lifecycle.r-lib.org/articles/stages.html#experimental)
[![R-CMD-check](https://github.com/jemarnold/mnirs/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/jemarnold/mnirs/actions/workflows/R-CMD-check.yaml)
[![Codecov test coverage](https://codecov.io/gh/jemarnold/mnirs/graph/badge.svg)](https://app.codecov.io/gh/jemarnold/mnirs)
<!-- badges: end -->

*{mnirs}* is a package for reading, processing, and analysing data from muscle near-infrared spectroscopy (mNIRS) devices.

## Installation

You can install the development version of *{mnirs}* from [GitHub](https://github.com/jemarnold/mnirs) with:

``` r
# install.packages("remotes")
remotes::install_github("jemarnold/mnirs")
```

## Citation

`<coming soon>`

## Online App

A very basic implementation of this package is hosted at https://jem-arnold.shinyapps.io/mnirs-app/ and can be used for mNIRS data importing and cleaning.

## Usage

A more detailed vignette for common usage can be found here: [Reading and Cleaning Data with {mnirs}](https://jemarnold.github.io/mnirs.dev/articles/cleaning-mnirs-data.html)

>[!NOTE]
> *{mnirs}* is currently in experimental development and functionality may change! Stay updated on development and follow releases at [github.com/jemarnold/mnirs](https://github.com/jemarnold/mnirs).

*{mnirs}* is designed to process mNIRS data, but there is no reason why it can't be used to read, clean, and filter other time series datasets, which require many of the same processing steps. Enjoy!

### `read_mnirs()` Read data from file

```{r}
# remotes::install_github("jemarnold/mnirs") ## install development version
library(ggplot2) ## load for plotting
library(mnirs)

## {mnirs} includes sample files from a few mNIRS devices
example_mnirs()

## partial matching will error if matches multiple
try(example_mnirs("moxy"))

## call an example mNIRS data file
file_path <- example_mnirs("moxy_ramp") 

## rename channels in the format `new_name1 = "original_name1"`
## where "original_name1" should match the file column name exactly
data_table <- read_mnirs(
    file_path,
    nirs_channels = c(smo2_right = "SmO2 Live", ## identify and rename channels
                      smo2_left = "SmO2 Live(2)"),
    time_channel = c(time = "hh:mm:ss"), ## date-time format will be converted to numeric
    event_channel = NULL,                ## left blank, not currently used in analysis
    sample_rate = NULL,                  ## sample_rate will be estimated from time column
    add_timestamp = FALSE,               ## omit the date-time timestamp column
    zero_time = TRUE,                    ## recalculate time values from zero
    keep_all = FALSE,                    ## return only the specified data channels
    inform = TRUE                        ## show warnings & messages
)

## ignore the warning about repeated samples for now â˜
## Note that sample_rate was estimated correctly at 2 Hz

data_table

## note the hidden plot option to display timestamp values as `hh:mm:ss`
plot(data_table, label_time = TRUE)
```

### Metadata stored in `mnirs` data frames

```{r}
#| echo: false
## hidden: remove the already defined parameter to demonstrate adding metadata
attr(data_table, "nirs_device") <- NULL
```

```{r}
## view metadata, omitting item two (a list of row numbers)
attributes(data_table)[-2]

## define nirs_channels externally for later use
nirs_channels <- attr(data_table, "nirs_channels")
nirs_channels

## add nirs device to metadata
data_table <- create_mnirs_data(data_table, nirs_device = "Moxy")

## check that the added metadata is now present
attr(data_table, "nirs_device")
```


### `replace_mnirs`: Replace local outliers, invalid values, and missing values


```{r}
data_cleaned <- replace_mnirs(
    data_table,
    nirs_channels = NULL,       ## default to all nirs_channels in metadata
    time_channel = NULL,        ## default to time_channel in metadata
    invalid_values = c(0, 100), ## known invalid values in the data
    outlier_cutoff = 3,         ## recommended default value
    width = 10,                 ## local window to detect local outliers and replace missing values
    method = "linear"           ## linear interpolation over `NA`s
)

plot(data_cleaned, label_time = TRUE)
```


### `resample_mnirs()`: Resample data

```{r}
data_resampled <- resample_mnirs(
    data_cleaned,
    # time_channel = NULL,        ## taken from metadata
    # sample_rate = NULL,
    # resample_rate = sample_rate ## the default will re-sample to sample_rate
    method = "linear",            ## default linear interpolation across any new samples
    inform = TRUE                 ## will confirm the output sample rate
)

## note the altered "time" values ðŸ‘‡
data_resampled
```


### `filter_mnirs()`: Digital filtering

```{r}
data_filtered <- filter_mnirs(
    data_resampled,
    # nirs_channel = NULL,  ## taken from metadata
    # time_channel = NULL,
    # sample_rate = NULLL,
    method = "butterworth", ## Butterworth digital filter is a common choice
    type = "low",           ## specify a low-pass filter
    n = 2,                  ## filter order number
    W = 0.02                ## filter fractional critical frequency
)

## we will add the non-filtered data back to the plot to compare
plot(data_filtered, label_time = TRUE) +
    geom_line(
        data = data_cleaned, 
        aes(y = smo2_left, colour = "smo2_left"), alpha = 0.4
    ) +
    geom_line(
        data = data_cleaned, 
        aes(y = smo2_right, colour = "smo2_right"), alpha = 0.4
    )
```


### `shift_mnirs()` & `rescale_mnirs()`: Shift and rescale data

```{r}
## our default *mnirs* nirs_channel will be grouped together
nirs_channels

## to shift each nirs_channel separately, the channels should be un-grouped
as.list(nirs_channels)

data_shifted <- shift_mnirs(
    data_filtered,
    nirs_channels = as.list(nirs_channels), ## un-grouped, as above
    to = 0,                                 ## NIRS values will be shifted to zero
    span = 120,                             ## shift the first 120 sec of data to zero
    position = "first"
)

plot(data_shifted, label_time = TRUE) +
    geom_hline(yintercept = 0, linetype = "dotted")
```


```{r}
data_rescaled <- rescale_mnirs(
    data_filtered,
    nirs_channels = as.list(nirs_channels), ## un-group `nirs_channels` to rescale each channel separately
    range = c(0, 100)                       ## rescale to a 0-100% functional exercise range
)

plot(data_rescaled, label_time = TRUE) +
    geom_hline(yintercept = c(0, 100), linetype = "dotted")
```


### Pipe-friendly functions

```{r}
## un-group `nirs_channels` to shift each channel separately
as.list(nirs_channels)

## then group `nirs_channels` to rescale together 
list(nirs_channels)

## pipe (base R `|>` or {magrittr} `%>%`) from one function to the next
data_rescaled <- data_filtered |> 
    ## shift the mean of the first 120 sec of each signal to zero
    shift_mnirs(
        nirs_channels = as.list(nirs_channels), ## un-grouped
        to = 0,
        position = "first",
        span = 120
    ) |> 
    ## then rescale the min and max of the grouped data to 0-100%
    rescale_mnirs(
        nirs_channels = list(nirs_channels), ## grouped
        range = c(0, 100)
    )

plot(data_rescaled, label_time = TRUE) +
    geom_hline(yintercept = c(0, 100), linetype = "dotted")
```

## mNIRS Device Compatibility

This package is designed to recognise mNIRS data exported as *.csv* or *.xls(x)* files. It should be flexible for use with many different mNIRS devices, and compatibility will improve with continued development.

Currently, it has been tested successfully with mNIRS data exported from the following devices and apps:

* [Artinis](https://www.artinis.com/oxysoft) Oxysoft software (.csv and .xlsx)
* [Moxy](https://www.moxymonitor.com/) direct export (.csv)
* [PerfPro](https://perfprostudio.com/) PC software (.xlsx)
* [Train.Red](https://train.red/) app (.csv)
* [VO2 Master Manager](https://vo2master.com/features/) app (.xlsx)

## Future *{mnirs}* Development

* Discrete interval processing

* Process oxygenation kinetics

    * Monoexponential & sigmoidal curve fitting
    
    * non-parametric kinetics & slope analysis

* Critical oxygenation breakpoint analysis

---

Generative codebots were used to assist with code optimisation. All code was thoroughly reviewed, revised, and validated by the package author.
